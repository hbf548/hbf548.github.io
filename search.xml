<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剖析SPRING-IOC源码（一）</title>
      <link href="/2020/07/12/%E5%89%96%E6%9E%90SPRING-IOC%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/07/12/%E5%89%96%E6%9E%90SPRING-IOC%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="剖析SPRING-IOC源码（一）"><a href="#剖析SPRING-IOC源码（一）" class="headerlink" title="剖析SPRING-IOC源码（一）"></a>剖析SPRING-IOC源码（一）</h1><p>花了3天时间来看源码，还是有点收获的，今天就来再次解析一次，就当是巩固</p><p>可能对于上一篇文章有点不满意，所以又重新进行一个spring-ioc源码的分析，话不多说，我们开始。</p><p><strong>这里先提前说一下什么Bean，什么是java对象，经过完整生命周期称为bean，也就是Spring Bean而java对象则是new出来的。Bean一定是java对象，而java对象不一定是Bean，简单的说就是bean是被spring管理的java对象</strong></p><p>首先我们先初始化Spring</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化Spring 上下文 容器 环境</span>AnnotationConfigApplicationContext context <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当然有的人是用后面这种方法，不过都一样的，都可以初始化，只是用后面这种方法是基于Xml构建你的spring</p><pre class=" language-java"><code class="language-java">ClassPathXmlApplicationContext classPathXmlApplicationContext <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">"spring.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>由于现在JavaConfig风格+注解的方式来使用Spring，是Spring官方主推的，也是现在的主流方式，所以我们这里用第一种方法。</p><p>创建<strong>AnnotationConfigApplicationContext</strong>对象，首先会跑到这里：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> annotatedClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用无参构造函数，会先调用父类GenericApplicationContext的构造函数</span><span class="token comment" spellcheck="true">//本类的构造函数里面，初始化了一个读取器：AnnotatedBeanDefinitionReader read，一个扫描器ClassPathBeanDefinitionScanner scanner</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//把传入的类进行注册，这里有两个情况，</span>        <span class="token comment" spellcheck="true">//传入传统的配置类</span>        <span class="token comment" spellcheck="true">//传入bean</span>        <span class="token comment" spellcheck="true">//看到后面会知道spring把传统的带上@Configuration的配置类称之为FULL配置类，不带@Configuration的称之为Lite配置类</span>        <span class="token comment" spellcheck="true">//但是我们这里先把带上@Configuration的配置类称之为传统配置类，不带的称之为普通bean</span>        <span class="token function">register</span><span class="token punctuation">(</span>annotatedClasses<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//刷新</span>        <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这个方法第一眼看上去，很简单，但是这三行代码包含了大千世界。</p><h3 id="第一行代码解析"><a href="#第一行代码解析" class="headerlink" title="第一行代码解析"></a>第一行代码解析</h3><p>我们先来看第一行代码，通过<code>this()</code>的无参构造方法，他会跑到这里</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//初始化一个Bean读取器</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotatedBeanDefinitionReader</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//初始化一个扫描器，它仅仅是在我们外部手动调用 .scan 等方法才有用，常规方式是不会用到scanner对象的</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathBeanDefinitionScanner</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>只有两行代码，但是不能直接看这两行代码，为什么呢？</p><p>因为我们的<strong>AnnotationConfigApplicationContext</strong>他有父类，它会调用父类里的参构造方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">GenericApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultListableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这个代码很简单，就是初始化了<strong>DefaultListableBeanFactory</strong>。</p><p>接下来我们就来看看<strong>DefaultListableBeanFactory</strong>的关系图</p><p><img src="1.jpg" alt=""></p><p><strong>DefaultListableBeanFactory是相当重要的</strong>，从字面意思就可以看出它是一个Bean的工厂，什么是Bean的工厂？当然就是用来生产和获得Bean的。这个我上篇文章也讲过，不懂得可以看看。</p><p>先回到<strong>AnnotationConfigApplicationContext</strong>的无参构造方法，让我们看看Spring在初始化<strong>AnnotatedBeanDefinitionReader</strong>的时候做了什么：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">AnnotatedBeanDefinitionReader</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token function">getOrCreateEnvironment</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这里的<strong>BeanDefinitionRegistry</strong>当然就是<strong>AnnotationConfigApplicationContext</strong>的实例了，这里又直接调用了此类其他的构造方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">AnnotatedBeanDefinitionReader</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">,</span> Environment environment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> <span class="token string">"BeanDefinitionRegistry must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>environment<span class="token punctuation">,</span> <span class="token string">"Environment must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>registry <span class="token operator">=</span> registry<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>conditionEvaluator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConditionEvaluator</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        AnnotationConfigUtils<span class="token punctuation">.</span><span class="token function">registerAnnotationConfigProcessors</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>看到这个方法的最后一行，进入<strong>registerAnnotationConfigProcessors</strong>方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerAnnotationConfigProcessors</span><span class="token punctuation">(</span>BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">registerAnnotationConfigProcessors</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>再点进去，这个方法的返回值Set，但是上游方法并没有去接收这个返回值，所以这个方法的返回值也不是很重要了，当然方法内部给这个返回值赋值也不重要了。由于这个方法内容比较多，这里就把最核心的贴出来，这个方法的核心就是注册Spring内置的多个Bean：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>beanFactory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getDependencyComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">AnnotationAwareOrderComparator</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                beanFactory<span class="token punctuation">.</span><span class="token function">setDependencyComparator</span><span class="token punctuation">(</span>AnnotationAwareOrderComparator<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">.</span><span class="token function">getAutowireCandidateResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">ContextAnnotationAutowireCandidateResolver</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                beanFactory<span class="token punctuation">.</span><span class="token function">setAutowireCandidateResolver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ContextAnnotationAutowireCandidateResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">containsBeanDefinition</span><span class="token punctuation">(</span>CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            RootBeanDefinition def <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>ConfigurationClassPostProcessor<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            def<span class="token punctuation">.</span><span class="token function">setSource</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>            beanDefs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token function">registerPostProcessor</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> def<span class="token punctuation">,</span> CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ol><li>判断容器中是否已经存在了<strong>ConfigurationClassPostProcessor</strong> Bean</li></ol><ol><li>如果不存在，就通过<strong>RootBeanDefinition</strong>的构造方法获得。</li></ol><ol><li>执行<strong>registerPostProcessor</strong>方法，<strong>registerPostProcessor</strong>方法内部就是注册Bean，当然这里注册其他Bean也是一样的流程。</li></ol><p>太难了，这不就是我上一篇讲的知识嘛— —</p><p><strong>ConfigurationClassPostProcessor</strong>的<strong>BeanDefinition</strong>，<strong>RootBeanDefinition</strong>是<strong>BeanDefinition</strong>的子类：</p><p><img src="2.jpg" alt=""></p><p>那么问题来了，<strong>BeanDefinition</strong>是什么？</p><p><strong>顾名思义，它是用来描述Bean的，里面存放着关于Bean的一系列信息，比如Bean的作用域，Bean所对应的Class，是否懒加载，是否Primary等等，这个BeanDefinition也相当重要，我们以后会常常和它打交道。</strong></p><p><strong>registerPostProcessor方法：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> BeanDefinitionHolder <span class="token function">registerPostProcessor</span><span class="token punctuation">(</span>            BeanDefinitionRegistry registry<span class="token punctuation">,</span> RootBeanDefinition definition<span class="token punctuation">,</span> String beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        definition<span class="token punctuation">.</span><span class="token function">setRole</span><span class="token punctuation">(</span>BeanDefinition<span class="token punctuation">.</span>ROLE_INFRASTRUCTURE<span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> definition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这方法为<strong>BeanDefinition</strong>设置了一个Role，ROLE_INFRASTRUCTURE代表这是spring内部的，并非用户定义的，然后又调用了<strong>registerBeanDefinition</strong>方法，</p><p>再点进去，你会发现它是一个接口，没办法直接点进去了，首先要知道registry实现类是什么，那么它的实现是什么呢？答案是<strong>DefaultListableBeanFactory</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> BeanDefinition beanDefinition<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeanDefinitionStoreException<span class="token punctuation">;</span></code></pre><p>再点进去，核心在于下面两行代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//这里就是把beanName作为key，ScopedProxyMode作为value，推到map里面</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//beanDefinitionNames就是一个List&lt;String>,这里就是把beanName放到List中去</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanDefinitionNames<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从这里可以看出<strong>DefaultListableBeanFactory</strong>就是我们所说的容器了，里面放着<strong>beanDefinitionMap</strong>，<strong>beanDefinitionNames</strong>，<strong>beanDefinitionMap</strong>是一个<strong>hashMap</strong>，<strong>beanName</strong>作为Key,<strong>beanDefinition</strong>作为Value，<strong>beanDefinitionNames</strong>是一个集合，里面存放了<strong>beanName</strong></p><p>这里仅仅是注册，可以简单的理解为把一些原料放入工厂，工厂还没有真正的去生产。</p><p><strong>上面已经介绍过，这里会一连串注册好几个Bean，在这其中最重要的一个Bean（没有之一）就是BeanDefinitionRegistryPostProcessor Bean。</strong></p><p><strong>ConfigurationClassPostProcessor实现BeanDefinitionRegistryPostProcessor接口，BeanDefinitionRegistryPostProcessor接口又扩展了BeanFactoryPostProcessor接口，BeanFactoryPostProcessor是Spring的扩展点之一，ConfigurationClassPostProcessor是Spring极为重要的一个类，必须牢牢的记住上面所说的这个类和它的继承关系。</strong></p><p><strong>BeanPostProcessor接口也是Spring的扩展点之一。</strong></p><p>好了，到这里实例化<strong>AnnotatedBeanDefinitionReader</strong> 已经分析完毕。</p><p>因为常规使用方式是不会用到<strong>AnnotationConfigApplicationContext</strong>里面的scanner的，所以这里就不解析scanner是如何被实例化的了。</p><h3 id="第二行代码解析"><a href="#第二行代码解析" class="headerlink" title="第二行代码解析"></a>第二行代码解析</h3><p>接下来开始分析第二行代码</p><pre class=" language-java"><code class="language-java"><span class="token function">register</span><span class="token punctuation">(</span>annotatedClasses<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里传进去的是一个数组，最终会循环调用如下方法：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBean</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> annotatedClass<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> qualifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//AnnotatedGenericBeanDefinition可以理解为一种数据结构，是用来描述Bean的，这里的作用就是把传入的标记了注解的类转为AnnotatedGenericBeanDefinition数据结构，里面有一个getMetadata方法，可以拿到类上的注解</span>        AnnotatedGenericBeanDefinition abd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotatedGenericBeanDefinition</span><span class="token punctuation">(</span>annotatedClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//判断是否需要跳过注解，spring中有一个@Condition注解，当不满足条件，这个bean就不会被解析</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>conditionEvaluator<span class="token punctuation">.</span><span class="token function">shouldSkip</span><span class="token punctuation">(</span>abd<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//解析bean的作用域，如果没有设置的话，默认为单例</span>        ScopeMetadata scopeMetadata <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>scopeMetadataResolver<span class="token punctuation">.</span><span class="token function">resolveScopeMetadata</span><span class="token punctuation">(</span>abd<span class="token punctuation">)</span><span class="token punctuation">;</span>        abd<span class="token punctuation">.</span><span class="token function">setScope</span><span class="token punctuation">(</span>scopeMetadata<span class="token punctuation">.</span><span class="token function">getScopeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获得beanName</span>        String beanName <span class="token operator">=</span> <span class="token punctuation">(</span>name <span class="token operator">!=</span> null <span class="token operator">?</span> name <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>beanNameGenerator<span class="token punctuation">.</span><span class="token function">generateBeanName</span><span class="token punctuation">(</span>abd<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//解析通用注解，填充到AnnotatedGenericBeanDefinition，解析的注解为Lazy，Primary，DependsOn，Role，Description</span>        AnnotationConfigUtils<span class="token punctuation">.</span><span class="token function">processCommonDefinitionAnnotations</span><span class="token punctuation">(</span>abd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//限定符处理，不是特指@Qualifier注解，也有可能是其他（理论上是任何注解，这里没有判断注解的有效性），如果我们在外面，以类似这种</span>        <span class="token comment" spellcheck="true">//AnnotationConfigApplicationContext annotationConfigApplicationContext = new AnnotationConfigApplicationContext(Appconfig.class);常规方式去初始化spring，</span>        <span class="token comment" spellcheck="true">//qualifiers永远都是空的，包括上面的name和instanceSupplier都是同样的道理</span>        <span class="token comment" spellcheck="true">//但是spring提供了其他方式去注册bean，就可能会传入了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>qualifiers <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//可以传入qualifier数组，所以需要循环处理</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> qualifier <span class="token operator">:</span> qualifiers<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//Primary注解优先</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Primary<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> qualifier<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    abd<span class="token punctuation">.</span><span class="token function">setPrimary</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//Lazy注解</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>Lazy<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">==</span> qualifier<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    abd<span class="token punctuation">.</span><span class="token function">setLazyInit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//其他，AnnotatedGenericBeanDefinition有个Map&lt;String,AutowireCandidateQualifier>属性，直接push进去</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                    abd<span class="token punctuation">.</span><span class="token function">addQualifier</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AutowireCandidateQualifier</span><span class="token punctuation">(</span>qualifier<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//把AnnotatedGenericBeanDefinition数据结构和beanName封装到一个对象中</span>        BeanDefinitionHolder definitionHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanDefinitionHolder</span><span class="token punctuation">(</span>abd<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        definitionHolder <span class="token operator">=</span> AnnotationConfigUtils<span class="token punctuation">.</span><span class="token function">applyScopedProxyMode</span><span class="token punctuation">(</span>scopeMetadata<span class="token punctuation">,</span> definitionHolder<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//注册，最终会调用DefaultListableBeanFactory中的registerBeanDefinition方法去注册</span>        <span class="token comment" spellcheck="true">//DefaultListableBeanFactory维护着一系列信息，比如beanDefinitionNames，beanDefinitionMap</span>        <span class="token comment" spellcheck="true">//beanDefinitionNames是一个List&lt;String>,用来保存beanName</span>        <span class="token comment" spellcheck="true">//beanDefinitionMap是一个Map,用来保存beanName和beanDefinition</span>BeanDefinitionReaderUtils<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>definitionHolder<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>在这里又要说明下，以常规方式去注册配置类，此方法中除了第一个参数，其他参数都是默认值。</p><p>1通过<strong>AnnotatedGenericBeanDefinition</strong>的构造方法，获得配置类的<strong>BeanDefinition</strong>，这里是不是似曾相似，在注册<strong>ConfigurationClassPostProcessor</strong>类的时候，也是通过构造方法去获得<strong>BeanDefinition</strong>的，只不过当时是通过<strong>RootBeanDefinition</strong>去获得，现在是通过<strong>AnnotatedGenericBeanDefinition</strong>去获得。</p><p>判断需不需要跳过注册，Spring中有一个@Condition注解，如果不满足条件，就会跳过这个类的注册。</p><p>这是上面代码的最后一步，也就是注册：</p><p>（调用<strong>DefaultListableBeanFactory</strong>中的<strong>registerBeanDefinition</strong>方法去注册）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>            BeanDefinitionHolder definitionHolder<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span>            <span class="token keyword">throws</span> BeanDefinitionStoreException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Register bean definition under primary name.</span>        String beanName <span class="token operator">=</span> definitionHolder<span class="token punctuation">.</span><span class="token function">getBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> definitionHolder<span class="token punctuation">.</span><span class="token function">getBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Register aliases for bean name, if any.</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> aliases <span class="token operator">=</span> definitionHolder<span class="token punctuation">.</span><span class="token function">getAliases</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>aliases <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String alias <span class="token operator">:</span> aliases<span class="token punctuation">)</span> <span class="token punctuation">{</span>                registry<span class="token punctuation">.</span><span class="token function">registerAlias</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> alias<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SPRING-IOC源码解析-BEAN的产生</title>
      <link href="/2020/07/12/SPRING-IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-BEAN%E7%9A%84%E4%BA%A7%E7%94%9F/"/>
      <url>/2020/07/12/SPRING-IOC%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-BEAN%E7%9A%84%E4%BA%A7%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="SPRING-IOC源码解析-BEAN的产生"><a href="#SPRING-IOC源码解析-BEAN的产生" class="headerlink" title="SPRING-IOC源码解析-BEAN的产生"></a>SPRING-IOC源码解析-BEAN的产生</h1><p>我们这边采用maven形式查看源码，因为gradle需要很长的配置工作，maven比较简单那，但是maven是不能编译源码的。<br>我是根据这篇文章解析源码的<a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring IOC 容器源码分析</a></p><p>首先定义注入依赖，spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span> <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span> <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>context<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span> <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">4.3</span><span class="token punctuation">.</span><span class="token number">11</span><span class="token punctuation">.</span>RELEASE<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span></code></pre><p>定义一个类AppConfig里面先不写东西</p><p><img src="1.jpg" alt=""></p><p><img src="2.jpg" alt=""></p><p>然后在test下的IocTest类启动Ioc容器</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * Rigorous Test :-)    */</span>   <span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shouldAnswerWithTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//启动ioc容器</span>        AnnotationConfigApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><img src="3.jpg" alt=""></p><p><img src="4.jpg" alt=""></p><p>在bean目录下新建一个User类，<br>那么问题来了我们怎么将这个类交给Spring管理的？<br>网上的教程都是创建spring.xml,我们这边就用spring注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>注意，此时还没有交给spring容器去管理<br>这边特意做了一个验证</p><p><img src="5.jpg" alt=""></p><p>因为只是加了注解还不能够交给spring容器去管理</p><p><strong>思考</strong>：</p><ul><li>为什么会抛一个NoSuchBeanDefinitionException异常呢，</li><li>BeanDefinition bean定义 承载bean属性：scope className mehtod—init</li><li>bean:交给ioc容器管理的对象就是bean</li></ul><p>要想交给spring容器管理，我们可以在Appconfig加一个扫描包</p><p><img src="6.jpg" alt=""></p><p>此时运行就能拿到</p><p><img src="7.jpg" alt=""></p><p><strong>回到上面的问题BeanDefinition 是个什么东西呢？</strong></p><pre class=" language-java"><code class="language-java">从这可以看出BeanDefinition他是一个接口<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanDefinition</span> <span class="token keyword">extends</span> <span class="token class-name">AttributeAccessor</span><span class="token punctuation">,</span> BeanMetadataElement<span class="token punctuation">{</span><span class="token comment" spellcheck="true">//定义了一个single 单列</span>        String SCOPE_SINGLETON <span class="token operator">=</span> ConfigurableBeanFactory<span class="token punctuation">.</span>SCOPE_SINGLETON<span class="token punctuation">;</span>定义了一个prototype 原型        String SCOPE_PROTOTYPE <span class="token operator">=</span> ConfigurableBeanFactory<span class="token punctuation">.</span>SCOPE_PROTOTYPE<span class="token punctuation">;</span>        承载了许多bean属性和方法<span class="token punctuation">,</span>就不细说了        <span class="token keyword">void</span> <span class="token function">setBeanClassName</span><span class="token punctuation">(</span>String beanClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setScope</span><span class="token punctuation">(</span>String scope<span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token function">getBeanClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setScope</span><span class="token punctuation">(</span>String scope<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setLazyInit</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> lazyInit<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">boolean</span> <span class="token function">isLazyInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setDependsOn</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> dependsOn<span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getDependsOn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setAutowireCandidate</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> autowireCandidate<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">isAutowireCandidate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setPrimary</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> primary<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">isPrimary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setFactoryBeanName</span><span class="token punctuation">(</span>String factoryBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token function">getFactoryBeanName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">setFactoryMethodName</span><span class="token punctuation">(</span>String factoryMethodName<span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token function">getFactoryMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConstructorArgumentValues <span class="token function">getConstructorArgumentValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MutablePropertyValues <span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> <span class="token function">isAbstract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token function">getRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String <span class="token function">getResourceDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BeanDefinition <span class="token function">getOriginatingBeanDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当然了 我们也可以构建Spring.xml，通过name来访问</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>beans xmlns<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans"</span>      xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>      xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span><span class="token string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="token operator">></span>   <span class="token operator">&lt;</span>bean id<span class="token operator">=</span><span class="token string">"user2"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.example.bean.User"</span> scope<span class="token operator">=</span><span class="token string">"prototype"</span><span class="token operator">/</span><span class="token operator">></span>   <span class="token operator">&lt;</span>bean name<span class="token operator">=</span><span class="token string">"user"</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.example.bean.User"</span> scope<span class="token operator">=</span><span class="token string">"prototype"</span><span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>beans<span class="token operator">></span></code></pre><p><img src="8.jpg" alt=""></p><pre class=" language-java"><code class="language-java">说明此时有个beanName这个属性，它可以通过id name找到对应得bean<span class="token punctuation">,</span>而id和name是交给BeanDefinitionRegistry（bean定义注册器）管理的，我们来看看它的源码<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanDefinitionRegistry</span> <span class="token keyword">extends</span> <span class="token class-name">AliasRegistry</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//注册BeanDefinition</span>        <span class="token keyword">void</span> <span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span>String beanName<span class="token punctuation">,</span> BeanDefinition beanDefinition<span class="token punctuation">)</span>                       <span class="token keyword">throws</span> BeanDefinitionStoreException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//beanName就是我们定义的id或者name    </span><span class="token comment" spellcheck="true">//而beanDefinition不就是承载bean属性嘛</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>接下来我们来验证一下我们为什么能拿到User对象</p><p><img src="9.jpg" alt=""></p><p>接下来再新建一个Fox，有什么方法不用定义去xml配置name和id就能直接交给spring管理呢</p><p>直接看图</p><p><img src="10.jpg" alt=""></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * Rigorous Test :-)    */</span>   <span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shouldAnswerWithTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//启动ioc容器</span>       AnnotationConfigApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//为什么会抛一个NoSuchBeanDefinitionException异常呢</span>       <span class="token comment" spellcheck="true">//BeanDefinition bean定义</span>       <span class="token comment" spellcheck="true">//bean:交给ioc容器管理的对象就是bean</span>       <span class="token comment" spellcheck="true">//beanName id name</span>        <span class="token comment" spellcheck="true">//BeanDefinitionRegistry  bean定义注册器</span>       context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//怎么将fox交给spring管理 将class对于的beanDefinition缓存到beanDefinitionMap beanName---beanDefinition(key,vule)</span>       BeanDefinition beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>Fox<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       context<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"fox"</span><span class="token punctuation">,</span>beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span>       context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"fox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们现在看一下</p><pre class=" language-java"><code class="language-java">context<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"fox"</span><span class="token punctuation">,</span>beanDefinition<span class="token punctuation">)</span></code></pre><p>这句代码是怎么去调的，把”fox”放到什么位置。</p><p>它首先会调用我们工厂的注册方法</p><p><img src="11.jpg" alt=""></p><p><img src="12.jpg" alt=""></p><p>然后在这bean定义了一个Map，我们可以进去看看</p><p><img src="13.jpg" alt=""></p><p>其实就是一个HashMap</p><p>然后通过put方法放进去</p><p><img src="14.jpg" alt=""></p><p>然后就可以看到fox，放到了beanDefinitionMap</p><p><img src="15.jpg" alt=""></p><p>当然也可以不用设置name，直接去注册类型，<br>因为register底层一定会去调beanDefinitionMap的put方法 这里就不再验证了</p><pre class=" language-java"><code class="language-java">BeanDefinition beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>Fox<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       context<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>Fox<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"fox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>算了，还是验证吧</p><p><img src="16.jpg" alt=""></p><p>看最终还是调到了registerBeanDefinition吧，然后又回到我们的注册器</p><p><img src="17.jpg" alt=""></p><p><strong>思考：不注册beanDefinition，能不能将对象交给spring容器管理呢</strong></p><p>通过beanFactory可以拿到一个对象，</p><p><img src="18.jpg" alt=""></p><p>由上面的继承结构图可以知道我们的AnnotationConfigApplicationContext也实现了bean工厂，所以我们可以直接拿到bean工厂，直接看代码吧，说多了没用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * Rigorous Test :-)    */</span>   <span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shouldAnswerWithTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//启动ioc容器</span>       AnnotationConfigApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//思考：不注册beanDefinition，能不能将对象交给spring容器管理呢</span>       <span class="token comment" spellcheck="true">//beanFactory:bean工厂 对象</span>       Monkey monkey <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Monkey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//获取工厂</span>       DefaultListableBeanFactory defaultListableBeanFactory <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getDefaultListableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//注册单例   将单例对象缓存到单例对象池中        defaultListableBeanFactory.registerSingleton("monkey",monkey);</span>       context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"monkey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果显示是可以的</p><p><img src="19.jpg" alt=""></p><p>我么干脆看一下registerSingleton方法都做了什么</p><p><img src="20.jpg" alt=""></p><p>发现调它父类的注册方法，然后添加单例到单例对象池singletonObjects中</p><p><img src="21.jpg" alt=""></p><p>可以知道singletonObjects也是一个map</p><p><img src="22.jpg" alt=""></p><p>也就是说我们所有的单例都是从单例对象池singletonObjects中去拿的。</p><p><strong>由此我们就得出结论：</strong></p><ul><li>bean的注册原理：将class对于的beanDefinition缓存到beanDefinitionMap中singletonObjects。</li><li>将所有创建的单例对象缓存到单例对象池singletonObjects中，下次再去调用时就是在单例对象池中去拿的，这里我们可以验证一下</li></ul><p>就是在这个方法里，我们继续看</p><p>这时候就拿到我们的monkey了</p><p><strong>无论什么装配方式，例如xml,@import等，它们最终解析之后都是为了拿到beanDefinition，然后通过注册器注册到beanDefinitionMap中</strong>，总之beanDefinition作用是非常大的。</p><p>比如可以填充属性<br>我们先在Fox定义两个属性</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Fox</span> <span class="token punctuation">{</span>   <span class="token keyword">private</span>  String name<span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>   <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token string">"Fox{"</span> <span class="token operator">+</span>                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IocTest</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/**    * Rigorous Test :-)    */</span>   <span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shouldAnswerWithTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//启动ioc容器</span>       AnnotationConfigApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span>AppConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       BeanDefinition beanDefinition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RootBeanDefinition</span><span class="token punctuation">(</span>Fox<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注册bean</span> context<span class="token punctuation">.</span><span class="token function">registerBeanDefinition</span><span class="token punctuation">(</span><span class="token string">"fox"</span><span class="token punctuation">,</span>beanDefinition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//填充普通属性 PropertyValues</span>       beanDefinition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"fox"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       beanDefinition<span class="token punctuation">.</span><span class="token function">getPropertyValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>Fox<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token string">"fox"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="23.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的索引是怎么加速查询的</title>
      <link href="/2020/07/12/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84/"/>
      <url>/2020/07/12/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E9%80%9F%E6%9F%A5%E8%AF%A2%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p><strong>Mysql的索引是怎么加速查询的</strong></p><p>昨天讲到了索引的基础知识<a href="https://lihaibincode.github.io/HB/2020/07/12/mysql/" target="_blank" rel="noopener">《爱上面试官》系列-数据库索引</a><br>事实上，在你还没有执行</p><pre class=" language-mysql"><code class="language-mysql">create index</code></pre><p>语句的时候，MySQL 就已经创建索引了。让我们从建表开始吧。</p><h1 id="1、聚簇索引"><a href="#1、聚簇索引" class="headerlink" title="1、聚簇索引"></a>1、聚簇索引</h1><p>执行建表语句：</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE `student` ( `id` BIGINT UNSIGNED AUTO_INCREMENT NOT NULL COMMENT '主键id', `student_no` VARCHAR(64) COMMENT '学号', `name` VARCHAR(64) COMMENT '学生姓名', `age` INT COMMENT '学生年龄', PRIMARY KEY (`id`)) ENGINE=InnoDB CHARSET=utf8mb4 COMMENT='学生信息表';</code></pre><p>插入 5 条数据：</p><pre class=" language-mysql"><code class="language-mysql">insert into student(student_no,name,age) values(101,"Alice",18);insert into student(student_no,name,age) values(102,"Bob",19);insert into student(student_no,name,age) values(104,"Brandt",15);insert into student(student_no,name,age) values(105,"David",19);insert into student(student_no,name,age) values(109,"David",18);</code></pre><p>在插入的过程中，MySQL 会用你指定的主键，在这里是递增主键，维护起一棵 B+树，我用了旧金山大学做的 BPlusTree Visualization 来模拟这棵树的样子，主键从 1 开始递增，插入五条，所以是 1 到5：</p><p><img src="2.jpg" alt=""></p><p>如果有时间，也建议你到这个网站去，从 1 到 5，一个一个插入，你会看到 B+树在插入的过程中是怎么维护它的几个特性的：</p><ul><li><p>有序：左边节点比右边小</p></li><li><p>自平衡：左右两边数量趋于相等</p></li><li><p>节点分裂：节点在遇到元素数量超过节点容量时，是如何分裂成两个的，这个也是 MySQL 页分裂的原理</p></li></ul><p>模拟工具只支持插入一个值，所以你看不到主键之外的其他数据，实际上，这棵 B+树的叶子节点是带有行的全部数据的，所以我又自己画了张完整的图：</p><p><img src="1.jpg" alt=""></p><p>如果没有这棵 B+树，你要根据主键查询，比如：</p><pre class=" language-mysql"><code class="language-mysql">select * from student where id = 5;</code></pre><p>对不起，数据是无序的，你只能全表扫描，犹如大浪淘沙。<br><strong>有同学会说主键不是递增的吗，那不就可以用二分法来查找？不是的，主键虽然是递增的，但是如果你写入磁盘时，没有去维护有序数组这样一个数据结构（比如你删掉了 4，怎么把 5 往前面挪），那数据在磁盘里依旧是无序的，查找时只能随机查找，而如果你维护了有序数组这样的数据结构，其实也是建了索引，只是建了不一样的数据结构的索引罢了。</strong><br><strong>至于为什么 MySQL 选择了B+树，而不用上面说的有序数组、hash索引等，咱们后面再聊。</strong></p><p>现在有了这棵 B+树，数据被有规律的存储起来，查找 id=5，也不再大浪淘沙，而是变得很有章法：</p><ul><li><p>从上到下，先找到 3，5 比它大，找右节点</p></li><li><p>接着找到 4，发现 5 还是比它大，继续找右节点</p></li><li><p>这次到达叶子节点了，叶子节点是一个递增的数组，那就用二分法，找到 id=5 的数据</p></li></ul><p><strong>你要访问磁盘的次数，是由这棵树的层数决定的</strong>。为了方便说明，我在文章里举的例子的数据量不会太大，所以用不用索引，性能提升的效果不明显，但是你可以脑补下大数据量的画面。<br>如果你没有指定主键呢？没关系，<strong>唯一键</strong>也可以。<br>连唯一键也没有？也没关系，mysql会给你建一个<strong>rowid字段</strong>，用它来组织这棵 B+树.<br>反正 MySQL 就一个目的，数据要有规律的存储起来，就像之前在 数据库是什么 里说的，数据是否被规律的管理起来，是数据库和文件系统区分开来的重要因素。<br><strong>这个 MySQL 无论如何都会建起来，并且存储有完整行数据的索引，就叫聚簇索引（clustered index）</strong>。</p><h1 id="2、二级索引"><a href="#2、二级索引" class="headerlink" title="2、二级索引"></a>2、二级索引</h1><p>聚簇索引只能帮你加快主键查询，但是如果你想根据姓名查询呢？<br>对不起，看看上面这棵树你就知道，数据并没有按照姓名进行组织，所以，你还是只能全表扫描。<br>不想全表扫描，怎么办？那就给姓名字段也加个索引，让数据按照姓名有规律的进行组织：</p><pre class=" language-mysql"><code class="language-mysql">create index idx_name on student(name);</code></pre><p>这时候 MySQL 又会建一棵新的 B+树：<br>你会发现这棵树的叶子节点，只有姓名和主键ID两个字段，没有行的完整数据，这时候你执行：</p><pre class=" language-mysql"><code class="language-mysql">select * from student where name = "David";</code></pre><p>MySQL到你刚刚创建的这棵 B+树 查询，快速查到有两条姓名是“David”的记录，并且拿到它们的主键，分别是 4 和 5，但是你要的是select *呀，怎么办？<br>别忘了，MySQL 在一开始就给你建了一棵 B+树 了，把这两棵树，放在一起，拿着从这棵树上查到的两个主键ID，去聚簇索引找，事情不就解决了？</p><p><strong>这个不带行数据完整信息的索引，就叫二级索引（secondary index），也叫辅助索引。</strong></p><h1 id="3、复合索引"><a href="#3、复合索引" class="headerlink" title="3、复合索引"></a>3、复合索引</h1><p>继续，如果我还想根据姓名和年龄同时查询呢？</p><pre class=" language-mysql"><code class="language-mysql">select * from student where name = "David" and age = 18;</code></pre><p>还是那个道理，数据虽然按照name 有规律的组织了，但是没有按照 age 有规律组织，所以我们要给 name 和 age 同时建索引：</p><pre class=" language-mysql"><code class="language-mysql">create index idx_name_age on student(name,age);</code></pre><p>这时候 MySQL 又会建一棵 B+树，这下 B+树 的节点里面，不只有 name，还有 age 了：<br>注意观察我用红色虚线框出来的那两个节点，这是这棵树和上面那棵只给 name 建索引的树的唯一区别，两个元素换了个位，<strong>因为排序时，是先用 name 比较大小，如果 name 相同，则用 age 比较。</strong><br>还是那句话，这里举的例子数据量很少，你可以想象下有一万个叫“David”的学生，年龄随机分布在 13 到 20 之间，这时候如果没有按照 age 进行有规律的存储，你还是得扫描一万行数据。</p><h1 id="4、未完待续"><a href="#4、未完待续" class="headerlink" title="4、未完待续"></a>4、未完待续</h1><p>我想起之前大学的一个学霸，人家考高数前都在背公式，他却在纸上练习这些公式的推导过程，纸上写的密密麻麻，当时不解，现在回想起来，这实在是降维打击。<br>别人都只会用公式，他却时刻牢记这些公式是怎么来的，别人考试就只会套用公式，他却可以用这些公式以外的知识解决问题。<br>MySQL索引也是，很多人都知道索引就像字典的目录，索引是 B+树，但是如果只知道这些，又有什么用呢？<br>知识是需要往深里学，才能转化为能力的，你知道的多，并不代表你能解决的问题就多，反而那些知道的没那么多，但是对他知道的东西，都研究透彻的人，才能一通百通。<br>当你知道了 MySQL 的索引长成这个样子后，还用去背什么“最左匹配”吗？<br>随便问个问题，只给student 表建 idx_name_age 这个复合索引，这两个 sql 语句，会走索引吗？</p><pre class=" language-mysql"><code class="language-mysql">select * from student where name = "David";</code></pre><pre class=" language-mysql"><code class="language-mysql">select * from student where age = 18;</code></pre><p>照着上面这几张图，你几乎可以推导出一切，什么样的 sql 能走索引，什么样的 sql 不能。<br>甚至，这么精妙的数据结构设计，难道就只能用来加速查询吗？<br>至少现在我能想到的，索引可以拿来干的事情，就至少有四种。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域</title>
      <link href="/2020/07/12/%E8%B7%A8%E5%9F%9F/"/>
      <url>/2020/07/12/%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="NODE跨域与解决处理"><a href="#NODE跨域与解决处理" class="headerlink" title="NODE跨域与解决处理"></a>NODE跨域与解决处理</h2><p><strong>跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。</strong><br>同源策略限制了一下行为：</p><ul><li><p>Cookie、LocalStorage 和 IndexDB 无法读取</p></li><li><p>DOM和 JS 对象无法获取</p></li><li><p>Ajax请求发送不出去</p></li></ul><p>只要是协议、域名、端口有任意一个不同的url都是不同的域。协议指的是http或者https协议。域名就是<a href="http://www.baidu.com和www.baidu.cn就是不同的域名。端口号的话就是默认的80端口和常用的3000或者8080端口它们都是不用的端口。" target="_blank" rel="noopener">www.baidu.com和www.baidu.cn就是不同的域名。端口号的话就是默认的80端口和常用的3000或者8080端口它们都是不用的端口。</a><br>拒绝跨域请求是浏览器为了保护用户的安全的一种策略。如果不经过浏览器的话就可以请求，比如服务端测接口常用的postMan，或者curl。</p><h2 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h2><p><a href="http://www.nealyang.cn/index.html" target="_blank" rel="noopener">http://www.nealyang.cn/index.html</a> 调用  <a href="http://www.nealyang.cn/server.php" target="_blank" rel="noopener">http://www.nealyang.cn/server.php</a> 非跨域</p><p><a href="http://www.nealyang.cn/index.html" target="_blank" rel="noopener">http://www.nealyang.cn/index.html</a> 调用  <a href="http://www.neal.cn/server.php" target="_blank" rel="noopener">http://www.neal.cn/server.php</a>  跨域,主域不同</p><p><a href="http://abc.nealyang.cn/index.html" target="_blank" rel="noopener">http://abc.nealyang.cn/index.html</a> 调用  <a href="http://def.neal.cn/server.php" target="_blank" rel="noopener">http://def.neal.cn/server.php</a>  跨域,子域名不同</p><p><a href="http://www.nealyang.cn:8080/index.html" target="_blank" rel="noopener">http://www.nealyang.cn:8080/index.html</a> 调用  <a href="http://www.nealyang.cn/server.php" target="_blank" rel="noopener">http://www.nealyang.cn/server.php</a> 跨域,端口不同</p><p><a href="https://www.nealyang.cn/index.html" target="_blank" rel="noopener">https://www.nealyang.cn/index.html</a> 调用  <a href="http://www.nealyang.cn/server.php" target="_blank" rel="noopener">http://www.nealyang.cn/server.php</a> 跨域,协议不同</p><p>localhost  调用 127.0.0.1 跨域</p><p><img src="https://i.loli.net/2021/04/13/feBaldAmjItpM5K.jpg" alt="1618228194641.jpg"></p><h2 id="为什么浏览器不支持跨域请求"><a href="#为什么浏览器不支持跨域请求" class="headerlink" title="为什么浏览器不支持跨域请求"></a>为什么浏览器不支持跨域请求</h2><p>为了保证安全性，防止CSRF攻击。CSRF(Cross-site request forgery),中文名称跨站请求伪造。<br>可以这么理解CSRF:攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。<br><strong>解决跨域的办法有N种，做常用的主要以下几种：</strong></p><ul><li><p>document.domain + iframe (只有在主域相同的时候才能使用该方法)</p></li><li><p>动态创建script</p></li><li><p>location.hash + iframe</p></li><li><p>window.name + iframe</p></li><li><p>postMessage（HTML5中的XMLHttpRequest Level 2中的API）</p></li><li><p>CORS</p></li><li><p>JSONP</p></li><li><p>web sockets不过解决跨域基本就两种方式，一种是客户端想方法，一般使用jsonp,另一种是服务端想办法，做配置（即CORS）。而CORS相对比较灵活，功能比较强大。</p></li></ul><h2 id="CORS解决跨域"><a href="#CORS解决跨域" class="headerlink" title="CORS解决跨域"></a>CORS解决跨域</h2><p>如果使用脚手架生成的express应用的话，express项目的app.js的最下面有一个处理404的中间件，如果不注释掉的话,CORS的预检请求回报404错误。<br>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">catch</span> <span class="token number">404</span> and forward to error handler app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span> var err <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Not Found'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span> <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。<br><strong>两种请求</strong><br>浏览器将CORS请求分成两类：<strong>简单请求</strong>（simple request）和<strong>非简单请求</strong>（not-so-simple request）。<br>只要同时满足以下两大条件，就属于简单请求。<br>（1) 请求方法是以下三种方法之一：</p><pre class=" language-java"><code class="language-java">HEADGETPOST</code></pre><p>（2）HTP的头信息不超出以下几种字段：</p><pre class=" language-java"><code class="language-java">AcceptAccept<span class="token operator">-</span>LanguageContent<span class="token operator">-</span>LanguageLast<span class="token operator">-</span>Event<span class="token operator">-</span>ID</code></pre><p>Content-Type：<strong>只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</strong>凡是不同时满足上面两个条件，就属于非简单请求。<br>浏览器对这两种请求的处理，是不一样的。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p><pre class=" language-java"><code class="language-java">GET <span class="token operator">/</span>cors HTTP<span class="token operator">/</span><span class="token number">1.1</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>comHost<span class="token operator">:</span> api<span class="token punctuation">.</span>alice<span class="token punctuation">.</span>comAccept<span class="token operator">-</span>Language<span class="token operator">:</span> en<span class="token operator">-</span>USConnection<span class="token operator">:</span> keep<span class="token operator">-</span>aliveUser<span class="token operator">-</span>Agent<span class="token operator">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。<br>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。<br>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息段。</p><pre class=" language-java"><code class="language-java">Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>comAccess<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Expose<span class="token operator">-</span>Headers<span class="token operator">:</span> FooBarContent<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span></code></pre><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p><strong>预检请求</strong><br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>下面是一段浏览器的JavaScript脚本。</p><pre class=" language-java"><code class="language-java">var url <span class="token operator">=</span> <span class="token string">'http://api.alice.com/cors'</span><span class="token punctuation">;</span>var xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'PUT'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'X-Custom-Header'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。<br>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><pre class=" language-java"><code class="language-java">OPTIONS <span class="token operator">/</span>cors HTTP<span class="token operator">/</span><span class="token number">1.1</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>comAccess<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Method<span class="token operator">:</span> PUTAccess<span class="token operator">-</span>Control<span class="token operator">-</span>Request<span class="token operator">-</span>Headers<span class="token operator">:</span> X<span class="token operator">-</span>Custom<span class="token operator">-</span>HeaderHost<span class="token operator">:</span> api<span class="token punctuation">.</span>alice<span class="token punctuation">.</span>comAccept<span class="token operator">-</span>Language<span class="token operator">:</span> en<span class="token operator">-</span>USConnection<span class="token operator">:</span> keep<span class="token operator">-</span>aliveUser<span class="token operator">-</span>Agent<span class="token operator">:</span> Mozilla<span class="token operator">/</span><span class="token number">5.0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p><p><strong>（1）Access-Control-Request-Method</strong><br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p><p><strong>（2）Access-Control-Request-Headers</strong><br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p><pre class=" language-java"><code class="language-java">HTTP<span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> OKDate<span class="token operator">:</span> Mon<span class="token punctuation">,</span> <span class="token number">01</span> Dec <span class="token number">2008</span> <span class="token number">01</span><span class="token operator">:</span><span class="token number">15</span><span class="token operator">:</span><span class="token number">39</span> GMTServer<span class="token operator">:</span> Apache<span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">.</span><span class="token function">61</span> <span class="token punctuation">(</span>Unix<span class="token punctuation">)</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>bob<span class="token punctuation">.</span>comAccess<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> GET<span class="token punctuation">,</span> POST<span class="token punctuation">,</span> PUTAccess<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> X<span class="token operator">-</span>Custom<span class="token operator">-</span>HeaderContent<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzipContent<span class="token operator">-</span>Length<span class="token operator">:</span> <span class="token number">0</span>Keep<span class="token operator">-</span>Alive<span class="token operator">:</span> timeout<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">100</span>Connection<span class="token operator">:</span> Keep<span class="token operator">-</span>AliveContent<span class="token operator">-</span>Type<span class="token operator">:</span> text<span class="token operator">/</span>plain</code></pre><p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="noopener">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p><pre class=" language-java"><code class="language-java">Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Origin<span class="token operator">:</span> <span class="token operator">*</span></code></pre><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p><pre class=" language-java"><code class="language-java">XMLHttpRequest cannot load http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">.</span>alice<span class="token punctuation">.</span>com<span class="token punctuation">.</span></code></pre><p>Origin <a href="http://api.bob.com/" target="_blank" rel="noopener">http://api.bob.com</a> is not allowed by Access-Control-Allow-Origin.服务器回应的其他CORS相关字段如下。</p><pre class=" language-java"><code class="language-java">Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods<span class="token operator">:</span> GET<span class="token punctuation">,</span> POST<span class="token punctuation">,</span> PUTAccess<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Headers<span class="token operator">:</span> X<span class="token operator">-</span>Custom<span class="token operator">-</span>HeaderAccess<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Max<span class="token operator">-</span>Age<span class="token operator">:</span> <span class="token number">1728000</span></code></pre><h2 id="CORS相关字段"><a href="#CORS相关字段" class="headerlink" title="CORS相关字段"></a>CORS相关字段</h2><p><strong>（1）Access-Control-Allow-Origin</strong><br>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p><p><strong>（2）Access-Control-Allow-Credentials</strong><br>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p><strong>（3）Access-Control-Expose-Headers</strong><br>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><p><strong>（4）Access-Control-Allow-Methods</strong><br>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p><strong>（5）Access-Control-Allow-Headers</strong><br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p><strong>（6）Access-Control-Max-Age</strong><br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><h2 id="withCredentials-属性允许发送cookie"><a href="#withCredentials-属性允许发送cookie" class="headerlink" title="withCredentials 属性允许发送cookie"></a>withCredentials 属性允许发送cookie</h2><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。</p><pre class=" language-java"><code class="language-java">Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Credentials<span class="token operator">:</span> <span class="token boolean">true</span></code></pre><p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p><pre class=" language-java"><code class="language-java">var xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。<br>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p><pre class=" language-java"><code class="language-java">`xhr<span class="token punctuation">.</span>withCredentials <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/2020/07/12/mysql/"/>
      <url>/2020/07/12/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="爱上面试官》系列-数据库索引"><a href="#爱上面试官》系列-数据库索引" class="headerlink" title="爱上面试官》系列-数据库索引"></a>爱上面试官》系列-数据库索引</h1><p>我看你简历上写到了熟悉MySQL数据库以及索引的相关知识，我们就从索引开始，索引有哪些数据结构？</p><p><img src="2.jpg" alt=""></p><p>Hash、Bx<br>为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为何Mysql独独喜欢B+树？<br>大家可以先看一下下面的动图</p><p><img src="1.jpg" alt=""></p><p>注意字段值所对应的数组下标是哈希算法随机算出来的，所以可能出现<strong>哈希冲突</strong>。<br>那么对于这样一个索引结构，现在来执行下面的sql语句：</p><pre class=" language-mysql"><code class="language-mysql">select * from sanguo where name='``鸡蛋'</code></pre><p>可以直接对‘鸡蛋’按哈希算法算出来一个数组下标，然后可以直接从数据中取出数据并拿到所对应那一行数据的地址，进而查询那一行数据， 那么如果现在执行下面的sql语句：</p><pre class=" language-mysql"><code class="language-mysql">select * from sanguo where name>'``鸡蛋'</code></pre><p>则无能为力，因为<strong>哈希表的特点就是可以快速的精确查询，但是不支持范围查询</strong>。<br>如果做成了索引，那速度也是很慢的，要全部扫描。</p><p><strong>你说的是无序的Hash表，那有没有有序的数据结构？</strong><br><strong>有序数组</strong>，它就比较优秀了呀，它在等值查询的和范围查询的时候都很Nice。</p><p><strong>那它完全没有缺点么？</strong><br>不是的，有序的适合静态数据，因为如果我们新增、删除、修改数据的时候就会改变他的结构。<br>比如你新增一个，那在你新增的位置后面所有的节点都会后移，成本很高。</p><p><strong>那照你这么说他根本就不优秀啊，特点也没地方放。</strong><br>此言差矣，可以用来做静态存储引擎啊，用来保存静态数据，例如你2019年的支付宝账单，2019年的淘宝购物记录等等都是很合适的，都是不会变动的历史数据。</p><p>二叉树是有序的，所以是支持范围查询的。<br>但是他的时间复杂度是O(log(N))，为了维持这个时间复杂度，更新的时间复杂度也得是O(log(N))，那就得保持这棵树是完全平衡二叉树了。</p><p><strong>怎么听你一说，平衡二叉树用来做索引还不错呢？</strong><br>此言差矣，索引也不只是在内存里面存储的，还是要落盘持久化的，可以看到图中才这么一点数据，如果数据多了，树高会很高，查询的成本就会随着树高的增加而增加。<br>为了节约成本很多公司的磁盘还是采用的机械硬盘，这样一次千万级别的查询差不多就要10秒了，这谁顶得住啊？</p><p><strong>如果用B树呢？</strong></p><p>可以发现同样的元素，B树的表示要比完全平衡二叉树要“矮”，原因在于B树中的一个节点可以存储多个元素。<br>B树其实就已经是一个不错的数据结构，用来做索引效果还是不错的。</p><p><strong>那为啥没用B树，而用了B+树？</strong><br>我们可以发现同样的元素，B+树的表示要比B树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连。</p><p><strong>那么B+树到底有什么优势呢？</strong><br>其实很简单，我们看一下上面的数据结构，最开始的Hash不支持范围查询，二叉树树高很高，只有B树跟B+有的一比。<br>B树一个节点可以存储多个元素，相对于完全平衡二叉树整体的树高降低了，磁盘IO效率提高了。<br>而B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是<strong>为了提高范围查找的效率。</strong><br>提高了的原因也无非是会有指针指向下一个节点的叶子节点。<br>小结：到这里可以总结出来，Mysql选用B+树这种数据结构作为索引，可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。</p><p><strong>你可以换个角度来思考B+树中一个节点到底多大合适？</strong><br><strong>B+树中一个节点为一页或页的倍数最为合适。</strong><br>因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费。<br>如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费。<br>所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。</p><p><strong>你提到了页的概念，能跟我简单说一下么？</strong><br>首先Mysql的基本存储结构是页(记录都存在页里边)：</p><ul><li><strong>各个数据页</strong>可以组成一个<strong>双向链表。</strong></li><li>而<strong>每个数据页中的记录</strong>又可以组成一个<strong>单向</strong>链表。</li><li>每个数据页都会为存储在它里边儿的记录生成一个<strong>页目录</strong>，在通过主键查找某条记录的时候可以在页目录中使用<strong>二分法快速定位</strong>到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</li><li>以<strong>其他列</strong>(非主键)作为搜索条件：只能从最小记录开始<strong>依次遍历单链表中的每条记录。</strong></li></ul><p>所以说，如果我们写 select * from user where username=’丙丙’这样没有进行任何优化的sql语句，默认会这样做：</p><ul><li>定位到记录所在的页</li><li>需要遍历双向链表，找到所在的页</li><li>从所在的页内中查找相应的记录</li><li>由于不是根据主键查询，只能遍历所在页的单链表了<br>很明显，在数据量很大的情况下这样查找会<strong>很慢</strong>！看起来跟回表有点点像。</li></ul><p><strong>哦？回表你聊一下。</strong><br>卧槽，该死，我嘴干嘛。<br>回表大概就是我们有个主键为ID的索引，和一个普通name字段的索引，我们在普通字段上搜索：sql select * from table where name = ‘丙丙’执行的流程是先查询到name索引上的“丙丙”，然后找到他的id是2，最后去主键索引，找到id为2对应的值。<br>回到主键索引树搜索的过程，就是<strong>回表</strong>。不过也有方法避免回表，那就是<strong>覆盖索引</strong>。</p><p><strong>哦？那你再跟我聊一下覆盖索引呗？</strong><br>！！！我这个嘴。。。<br>这个其实比较好理解，刚才我们是select * ，查询所有的，我们如果只查询ID那，其实在Name字段的索引上就已经有了，那就不需要回表了。<br>覆盖索引可以减少树的搜索次数，提升性能，他也是我们在实际开发过程中经常用来优化查询效率的手段。<br>很多联合索引的建立，就是为了支持覆盖索引，特定的业务能极大的提升效率。</p><p><strong>索引的最左匹配原则知道么？</strong><br><strong>最左匹配原则</strong>：</p><ul><li><p>索引可以简单如一个列 (a)，也可以复杂如多个列 (a,b,c,d)，即联合索引。</p></li><li><p>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是<strong>否存在（相等）</strong>，遇到范围查询 (&gt;、&lt;、between、like左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</p></li><li><p>因此，列的排列顺序决定了可命中索引的列数。</p><p>例子：<br>如有索引 (a,b,c,d)，查询条件 a=1 and b=2 and c&gt;3 and d=4，则会在每个节点依次命中a、b、c，无法命中d。(c已经是范围查询了，d肯定是排不了序了)</p></li></ul><p><strong>总结：</strong><br>上面谈的其实就是索引<strong>最基本</strong>的东西，N叉树，跳表、LSM我都没讲，同时要创建出好的索引要顾及到很多的方面：</p><ul><li><strong>最左前缀匹配原则</strong>。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询 （&gt;,&lt;,BETWEEN,LIKE）就停止匹配。</li><li>尽量选择<strong>区分度高的列作为索引</strong>，区分度的公式是 COUNT(DISTINCT col)/COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。</li><li><strong>索引列不能参与计算，尽量保持列“干净”</strong>。比如，FROM_UNIXTIME(create_time)=’2016-06-06’ 就不能使用索引，原因很简单，<strong>B+树中存储的都是数据表中的字段值</strong>，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ：create_time=UNIX_TIMESTAMP(‘2016-06-06’)。</li><li>尽可能的<strong>扩展索引</strong>，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</li><li>单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，</li><li>“合并索引”策略简单来讲，就是使用多个单列索引，然后将这些结果用“union或者and”来合并起来</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
